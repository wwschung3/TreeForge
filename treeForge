#!/bin/sh
#
# treeForge – build a file/directory tree from a diagram file (txt or json)
#
# Author:  Senior Bash Engineer
# Date:    2025‑08‑19
#
# Usage:  treeForge [options] <diagram_file> [destination_dir]
#
# Options:
#   -l <depth>      Limit the tree depth to <depth> (0 = unlimited, default)
#   -g              Enable .gitignore handling (default)
#   -n              Disable .gitignore handling
#   -h              Show this help message
#
# The script expects an auxiliary file `functions.sh` in the same directory.
# That file must export the functions used below (process_line, etc.).
#

# --------------------------------------------------------------------------- #
# Helper: print usage and exit
# --------------------------------------------------------------------------- #
usage() {
    cat <<EOF 1>&2
Usage: $0 [options] <diagram_file> [destination_dir]
Options:
  -l <depth>      Limit the tree depth to <depth> (0 = unlimited, default)
  -g              Enable .gitignore handling (default)
  -n              Disable .gitignore handling
  -h              Show this help message
EOF
    exit 1
}

# --------------------------------------------------------------------------- #
# Parse command‑line arguments
# --------------------------------------------------------------------------- #
USE_GITIGNORE=1        # default: honour .gitignore
LEVEL_LIMIT=0          # default: no depth limit

# Shift through flags
while getopts ":l:gnh" opt; do
    case $opt in
        l)
            case "$OPTARG" in
                ''|*[!0-9]*) echo "ERROR: -l requires a numeric argument" >&2; usage ;;
            esac
            LEVEL_LIMIT=$OPTARG
            ;;
        g) USE_GITIGNORE=1 ;;
        n) USE_GITIGNORE=0 ;;
        h) usage ;;
        \?)
            echo "ERROR: Unknown option -$OPTARG" >&2
            usage ;;
    esac
done
shift $((OPTIND - 1))

# --------------------------------------------------------------------------- #
# Require at least one positional argument (diagram file)
# --------------------------------------------------------------------------- #
if [ $# -lt 1 ]; then
    echo "ERROR: Diagram file is mandatory" >&2
    usage
fi

DIAGRAM_FILE=$1
shift

# --------------------------------------------------------------------------- #
# Destination directory: default = current working directory
# --------------------------------------------------------------------------- #
if [ $# -ge 1 ]; then
    DEST_DIR=$1
else
    DEST_DIR=$(pwd)
fi

# Resolve DEST_DIR to an absolute path
if [ ! -d "$DEST_DIR" ]; then
    echo "ERROR: Destination directory '$DEST_DIR' does not exist or is not a directory" >&2
    exit 1
fi

ROOT_DIR=$(cd "$DEST_DIR" && pwd)

# --------------------------------------------------------------------------- #
# .gitignore path (if it exists)
# --------------------------------------------------------------------------- #
GITIGNORE_PATH="$ROOT_DIR/.gitignore"
if [ ! -e "$GITIGNORE_PATH" ]; then
    GITIGNORE_PATH=
fi

# --------------------------------------------------------------------------- #
# Export variables that functions.sh expects
# --------------------------------------------------------------------------- #
export ROOT_DIR
export LEVEL_LIMIT
export USE_GITIGNORE
export GITIGNORE_PATH

# --------------------------------------------------------------------------- #
# Helper Library
# --------------------------------------------------------------------------- #

# Global variable to maintain the path context
declare -a PATH_STACK

# Define all known tree diagram glyphs
declare -a TREE_GLYPHS=(' ' ' ' '│' '┃' '├' '┣' '└' '┗' '─' '──')

# --------------------------------------------------------------------------- #
# Utility helpers
# --------------------------------------------------------------------------- #

# trim_trailing_newlines - remove trailing CR/LF from a string
trim_trailing_newlines() {
    printf '%s' "$1" | tr -d '\r\n'
}

# --------------------------------------------------------------------------- #
# 1. Parsing the diagram
# --------------------------------------------------------------------------- #

# parse_line
parse_line() {
    local raw_line="$1"
    local rest="${raw_line}"

    # --- 1. Strip leading whitespace from the entire line ----------------
    rest="${rest#"${rest%%[![:space:]]*}"}"

    # --- 2. Count glyphs and strip them --------------------------------
    LINE_DEPTH=0
    local matched=
    while true; do
        matched=""
        for g in "${TREE_GLYPHS[@]}"; do
            if [ "${rest#"${g}"}" != "$rest" ]; then
                matched="$g"
                break
            fi
        done

        if [ -z "$matched" ]; then
            break
        fi

        LINE_DEPTH=$((LINE_DEPTH + 1))
        rest="${rest#"$matched"}"
        rest="${rest#"${rest%%[![:space:]]*}"}"
    done

    # --- 3. The remaining string is the item's name
    local item_name="${rest}"

    # --- 4. Build the full relative path using the path stack
    PATH_STACK=("${PATH_STACK[@]:0:$LINE_DEPTH}")
    PATH_STACK[$LINE_DEPTH]="$item_name"
    local path_components
    path_components=$(IFS=/; echo "${PATH_STACK[*]:1}")
    REL_PATH="$path_components"

    export LINE_DEPTH
    export REL_PATH
}

# parse_json_item
#   Process a single JSON item (file or directory) from project_structure.json
#   Parameters:
#     $1 – JSON item (path, type, children)
#     $2 – current depth
parse_json_item() {
    local json_item="$1"
    local depth="$2"

    # Extract path and type using basic string manipulation (requires jq)
    local path=$(echo "$json_item" | jq -r '.path')
    local type=$(echo "$json_item" | jq -r '.type')

    # Set global variables for consistency with parse_line
    LINE_DEPTH=$depth
    REL_PATH="$path"

    # Check if item should be created
    should_create || return 0

    # Check if item is gitignored
    if is_gitignored; then
        printf 'Ignored by .gitignore: %s\n' "$REL_PATH"
        return 0
    fi

    # Create the item
    create_item

    # If directory, process children recursively
    if [ "$type" = "dir" ]; then
        local children=$(echo "$json_item" | jq -c '.children[]')
        local child
        echo "$children" | while IFS= read -r child; do
            parse_json_item "$child" $((depth + 1))
        done
    fi
}

# --------------------------------------------------------------------------- #
# 2. Decision logic
# --------------------------------------------------------------------------- #

# should_create
should_create() {
    if [ "$LEVEL_LIMIT" -gt 0 ] && [ "$LINE_DEPTH" -gt "$LEVEL_LIMIT" ]; then
        return 1
    fi

    local abs_path="$ROOT_DIR/$REL_PATH"
    if [ -e "$abs_path" ]; then
        return 1
    fi

    return 0
}

# is_gitignored
is_gitignored() {
    if [ "$USE_GITIGNORE" -ne 1 ] || [ -z "$GITIGNORE_PATH" ]; then
        return 1
    fi

    if [ ! -r "$GITIGNORE_PATH" ]; then
        return 1
    fi

    while IFS= read -r rule || [ -n "$rule" ]; do
        rule=$(printf '%s' "$rule" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [ -z "$rule" ] || [ "${rule#\#}" != "$rule" ]; then
            continue
        fi

        pattern="$rule"
        case "$pattern" in
            */) pattern="${rule%/}/*" ;;
        esac

        case "$REL_PATH" in
            $pattern) return 0 ;;
        esac
    done < "$GITIGNORE_PATH"

    return 1
}

# --------------------------------------------------------------------------- #
# 3. Creating the item
# --------------------------------------------------------------------------- #

# create_item
create_item() {
    local abs_path="$ROOT_DIR/$REL_PATH"

    case "$REL_PATH" in
        *.*)  # contains a dot → treat as file
            if ! touch "$abs_path" 2>/dev/null; then
                printf 'ERROR: Failed to touch file "%s"\n' "$abs_path" >&2
                exit 1
            fi
            printf 'Created file:   %s\n' "$REL_PATH"
            ;;
        *)    # otherwise → treat as directory
            if ! mkdir -p "$abs_path" 2>/dev/null; then
                printf 'ERROR: Failed to mkdir "%s"\n' "$abs_path" >&2
                exit 1
            fi
            printf 'Created dir :   %s\n' "$REL_PATH"
            ;;
    esac
}

# --------------------------------------------------------------------------- #
# 4. Public wrapper – what the main script calls
# --------------------------------------------------------------------------- #

# process_line
process_line() {
    local raw_line="$1"
    [ -z "$raw_line" ] && return 0
    parse_line "$raw_line"
    should_create || return 0
    if is_gitignored; then
        printf 'Ignored by .gitignore: %s\n' "$REL_PATH"
        return 0
    fi
    create_item
}

# --------------------------------------------------------------------------- #
# Main processing loop
# --------------------------------------------------------------------------- #

# Check file extension to determine processing method
case "$DIAGRAM_FILE" in
    *.json)
        # Ensure jq is available
        if ! command -v jq >/dev/null 2>&1; then
            echo "ERROR: jq is required to process JSON files" >&2
            exit 1
        fi

        # Read and process JSON file
        items=$(jq -c '.[]' "$DIAGRAM_FILE")
        echo "$items" | while IFS= read -r item; do
            parse_json_item "$item" 1
        done
        ;;
    *)
        # Process text file as before
        while IFS= read -r line || [ -n "$line" ]; do
            [ -z "$line" ] && continue
            process_line "$line"
        done < "$DIAGRAM_FILE"
        ;;
esac

echo "Tree creation completed."

# End of script